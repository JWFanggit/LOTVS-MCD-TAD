import torch
import numpy as np

# device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

device = torch.device('cuda:0')


# 框
# def rmse_loss_fol(x_pred, x_true):
#     '''
#     Params:
#         x_pred: (batch_size, segment_len, pred_dim)
#         x_true: (batch_size, segment_len, pred_timesteps, pred_dim)
#     Returns:
#         rmse: scalar, rmse = \sum_{i=1:batch_size}()
#     '''
#
#     L2_diff = torch.sqrt(torch.sum((x_pred - x_true) ** 2, dim=2))
#     # sum over prediction time steps
#     L2_all_pred = torch.sum(L2_diff, dim=1)
#     # mean of each frames predictions
#     L2_mean_pred = torch.mean(L2_all_pred, dim=0)
#     # sum of all batches
#     return L2_mean_pred


# 帧
def intensity_loss(gen_frames, gt_frames, l_num=2):
    x = torch.mean(torch.abs((gen_frames - gt_frames) ** l_num)).to(device)
    return x.to(device)


def gradient_loss(gen_frames, gt_frames, alpha):
    pos = torch.tensor(np.identity(3), dtype=torch.float32).to(device)
    neg = -1 * pos
    mid = torch.zeros([3, 3], dtype=torch.float32).to(device)
    filter_x = torch.unsqueeze(torch.stack([neg, mid, pos]), 0).to(device)  # [-1, 1]
    filter_y = torch.unsqueeze(torch.stack([pos, mid, neg]), 0).to(device)  # [-1, 1]

    gen_dx = torch.abs(torch.conv2d(gen_frames, filter_x, None, 1, padding=1))
    gen_dy = torch.abs(torch.conv2d(gen_frames, filter_y, None, 1, padding=1))
    gt_dx = torch.abs(torch.conv2d(gt_frames, filter_x, None, 1, padding=1))
    gt_dy = torch.abs(torch.conv2d(gt_frames, filter_y, None, 1, padding=1))
    grad_diff_x = torch.abs(gt_dx - gen_dx)
    grad_diff_y = torch.abs(gt_dy - gen_dy)
    return torch.mean(grad_diff_x ** alpha + grad_diff_y ** alpha)


def psnr_error(gen_frames, gt_frames):
    """
    Computes the Peak Signal to Noise Ratio error between the generated images and the ground
    truth images.

    @param gen_frames: A tensor of shape [batch_size, height, width, 3]. The frames generated by the
                       generator model.
    @param gt_frames: A tensor of shape [batch_size, height, width, 3]. The ground-truth frames for
                      each frame in gen_frames.

    @return: A scalar tensor. The mean Peak Signal to Noise Ratio error over each frame in the
             batch.
    """

    if gen_frames.shape[-1] != 3 and gen_frames.shape[1] == 3:
        gen_frames = gen_frames.permute(0, 2, 3, 1).contiguous()
        gt_frames = gt_frames.permute(0, 2, 3, 1).contiguous()#维度调整，将类别放置在最后一维度   [N, H, W, C] --> (batch_size, 256, 256, 3)

    shape = gen_frames.shape

    num_pixels = (shape[1] * shape[2] * shape[3])

    gt_frames = ((gt_frames + 1.0) / 2.0).to(device)
    gen_frames = ((gen_frames + 1.0) / 2.0).to(device)
    square_diff = torch.square(gt_frames - gen_frames).to(device)

    batch_errors = 10 * torch.log10(1 / ((1 / num_pixels) * square_diff.sum([1, 2, 3])))
    return torch.mean(batch_errors)


def compute_IOU(bbox_pred, bbox_true, format='x1y1x2y2'):
    '''
    compute IOU
    [cx, cy, w, h] or [x1, y1, x2, y2]
    '''
    if format == 'xywh':
        xmin = np.max([bbox_true[0] - bbox_true[2] / 2, bbox_pred[0] - bbox_pred[2] / 2])
        xmax = np.min([bbox_true[0] + bbox_true[2] / 2, bbox_pred[0] + bbox_pred[2] / 2])
        ymin = np.max([bbox_true[1] - bbox_true[3] / 2, bbox_pred[1] - bbox_pred[3] / 2])
        ymax = np.min([bbox_true[1] + bbox_true[3] / 2, bbox_pred[1] + bbox_pred[3] / 2])
        w_true = bbox_true[2]
        h_true = bbox_true[3]
        w_pred = bbox_pred[2]
        h_pred = bbox_pred[3]
    elif format == 'x1y1x2y2':
        xmin = np.max([bbox_true[0], bbox_pred[0]])
        xmax = np.min([bbox_true[2], bbox_pred[2]])
        ymin = np.max([bbox_true[1], bbox_pred[1]])
        ymax = np.min([bbox_true[3], bbox_pred[3]])
        w_true = bbox_true[2] - bbox_true[0]
        h_true = bbox_true[3] - bbox_true[1]
        w_pred = bbox_pred[2] - bbox_pred[0]
        h_pred = bbox_pred[3] - bbox_pred[1]
    else:
        raise NameError("Unknown format {}".format(format))
    w_inter = np.max([0, xmax - xmin])
    h_inter = np.max([0, ymax - ymin])
    intersection = w_inter * h_inter
    union = (w_true * h_true + w_pred * h_pred) - intersection

    return intersection / union


def My_iou(pre, true):
    res = 0
    for x, y in zip(pre, true):
        res += compute_IOU(x, y)
    return res / pre.shape[0]
